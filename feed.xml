<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>(replicate thoughts)</title>
    <description>A blog about distributed systems, machine learning and critical theory.</description>
    <link>https://whilo.github.io/</link>
    <atom:link href="https://whilo.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 12 Nov 2016 12:14:06 +0100</pubDate>
    <lastBuildDate>Sat, 12 Nov 2016 12:14:06 +0100</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Reasonable unified storage IO</title>
        <description>&lt;h2 id=&quot;why-not-just-use-store-x&quot;&gt;Why not just use store X?&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;newthought&quot;&gt;Durability should be simple and flexible.&lt;/span&gt;  When I started to
design &lt;a href=&quot;https://github.com/replikativ/replikativ&quot;&gt;replikativ&lt;/a&gt; I investigated
many different IO options, including many key-value or document stores like
CouchDB, Riak, MongoDB, IndexedDB etc. &lt;!--more--&gt; My trouble was that I wanted
to have cross-platform code also targeting ClojureScript while I didn’t need a
particular storage access pattern from the start. Also deciding for any
particular storage is in most cases premature as IO specific requirements change
in the lifecycle of an application. &lt;label for=&quot;Four&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Four&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;In my experience people
tend to use one or two storage solutions they know instead of using something
minimilastic and then plugging in a more elaborate storage solution when their
application needs it. This then complects what features are really required by
the application and what is used just because the storage solution prescribes
it. &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;With ClojureScript in particular a problem arises, as this is not a local
decision which can be factored away, but either you introduce callbacks
everywhere or you default
to &lt;a href=&quot;https://github.com/clojure/core.async&quot;&gt;core.async&lt;/a&gt;, besides other more
exotic options. You then need to wrap all your code in go-routines for
ClojureScript and hence platform-neutral code becomes in the same way affected
as code is by IO in Haskell. Since I wanted to have a reasonable default, we
picked the back then new core.async and get a sane sequential programming model.
This put me out of luck, as all previous JVM libraries and approaches use
synchronous IO. I also wanted to start with the minimum necessary, which was the
semantics of a Clojure hash-map for me.&lt;/p&gt;

&lt;p&gt;The situation has barely changed as truely platform neutral code for IO
operations like storage and network is not yet well established in the
Clojure(Script) community. &lt;a href=&quot;https://github.com/replikativ/konserve&quot;&gt;konserve&lt;/a&gt;
(for storage IO) and &lt;a href=&quot;https://github.com/replikativ/kabel&quot;&gt;kabel&lt;/a&gt; (for network
IO) are efforts to change that and significantly facilitate the development with
core.async.&lt;/p&gt;

&lt;h2 id=&quot;flexibility-by-simplicity&quot;&gt;Flexibility by simplicity&lt;/h2&gt;

&lt;p&gt;&lt;label for=&quot;Two&quot; class=&quot;margin-toggle&quot;&gt; ⊕&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Two&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;marginnote&quot;&gt;Simple and flexible way to store things reliably. Both the
material and the language can be switched to address different
tradeoffs:
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Lachish_III_obv.JPG/595px-Lachish_III_obv.JPG&quot; alt=&quot;Historic piece of stone with letters&quot; /&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I designed and we use konserve in production as a simple interface to do common
tasks like &lt;em&gt;session storages&lt;/em&gt; in backends, file storage for &lt;em&gt;caches of binary
data&lt;/em&gt; in Clojure(Script) and in general any way to durably &lt;em&gt;store state&lt;/em&gt; when
Datomic’s query capabilities are not necessary. Furthermore advanced storage
concepts should be facilitated by such a building block for persistent
datastructure concepts, e.g.
the &lt;a href=&quot;https://github.com/datacrypt-project/hitchhiker-tree&quot;&gt;hitchhiker-tree&lt;/a&gt;
or &lt;a href=&quot;https://github.com/replikativ/durable-persistence&quot;&gt;durable-persistence&lt;/a&gt; and
particulary for
the
&lt;a href=&quot;https://github.com/replikativ/replikativ/tree/master/src/replikativ/crdt&quot;&gt;CRDTs in replikativ&lt;/a&gt;.
So what is desired?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;simple&lt;/em&gt;&lt;label for=&quot;Three&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Three&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;In Rich Hickey’s sense as logically simple. &lt;/span&gt;
durable IO protocol as a building block&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;composable&lt;/em&gt; to more sophisticated semantics, e.g. append-log&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;threadsafe&lt;/em&gt; and safe to use without draining core.async’s threadpool with
synchronous IO&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ACID&lt;/em&gt; properties on the key level, where consistency and durability depend on
the underlying store while atomicity and isolation are provided by konserve&lt;/li&gt;
  &lt;li&gt;should be reasonable for &lt;em&gt;95% of usage&lt;/em&gt;: both in &lt;em&gt;performance&lt;/em&gt; and &lt;em&gt;function&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;minimalism&lt;/em&gt;: pluggable different backend stores fullfilling konserve semantics:
memory, filestore, IndexedDB, LevelDB, redis, riak, CouchDB&lt;/li&gt;
  &lt;li&gt;natural Clojure interface with &lt;a href=&quot;https://github.com/edn-format/edn&quot;&gt;edn&lt;/a&gt;
&lt;em&gt;associative key-value semantics&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;first-class, &lt;em&gt;pluggable serialization&lt;/em&gt; mechanism
(through &lt;a href=&quot;https://github.com/replikativ/incognito&quot;&gt;incognito&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;allow &lt;em&gt;raw binary&lt;/em&gt; IO if desired&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;hosted&lt;/em&gt; concept with transparent access to the underlying store&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;minimal dependencies&lt;/em&gt; by default&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By reducing the storage interface to a simple key-value store with a core.async
interface and edn serialization one gets a very good tradeoff to not having to
reason about the interface:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;&amp;lt;!!&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;k/assoc-in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;:bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;&amp;lt;!!&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;k/update-in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;:bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;; =&amp;gt; [42 43]
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;&amp;lt;!!&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;k/get-in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;:bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;opting-out&quot;&gt;Opting out&lt;/h2&gt;

&lt;p&gt;It is still possible to get gradually more &lt;em&gt;direct access&lt;/em&gt; to the underlying
store possible, e.g. for performance or specific features like transactional
safety or batch processing, similar to the way Clojure exposes the underlying
JVM primitives and interfaces. Konserve furthermore reuses popular Clojure
libraries for backends where possible to not reinvent the wheel and allow
comfortable direct access. Konserve provides a reasonable default store without
dependencies or setup required for the JVM (filestore) and the Browser
(IndexedDB).&lt;/p&gt;

&lt;p&gt;Performance is fairly good for small key-value pairs accessed in parallel, which
is exploited for instance in replikativ by using Merkle-Tree like structures. In
general you pay a neglegible cost for the konserve protocol and the usual cost
for edn serialization depending on the serializer. The implementation of more
advanced storage features on top is intended, for instance a fast append-log
with reduction is already implemented and used in replikativ. &lt;label for=&quot;One&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;One&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;A write-through caching scheme could also become attractive as well as a small
REST interface exposing konserve operations. &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Dealing with errors in core.async &lt;a href=&quot;https://whilo.github.io/articles/16/error-handling1&quot;&gt;is not always easy&lt;/a&gt;, so it can be helpful to
use &lt;a href=&quot;https://github.com/replikativ/superv.async&quot;&gt;superv.async&lt;/a&gt; instead of plain
core.async. Errors happening are returned as wrapped exceptions and need to be
rethrown in case you expect this. I hope you find it a useful storage default
and report back in
the
&lt;a href=&quot;https://gitter.im/replikativ/replikativ?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&quot;&gt;gitter chat&lt;/a&gt; or
on the Clojure mailing list. Happy storing! :)&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Nov 2016 01:05:21 +0100</pubDate>
        <link>https://whilo.github.io/articles/16/unified-storage-io</link>
        <guid isPermaLink="true">https://whilo.github.io/articles/16/unified-storage-io</guid>
        
        
        <category>clojure</category>
        
        <category>core.async</category>
        
        <category>konserve</category>
        
        <category>replikativ</category>
        
      </item>
    
      <item>
        <title>Erlang inspired error handling with superv.async.</title>
        <description>&lt;h2 id=&quot;clojure-error-handling&quot;&gt;Clojure error handling&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;newthought&quot;&gt;Proper error handling is hard.&lt;/span&gt;  I have struggled with it often
without recognizing it. You might think that you can add &lt;code class=&quot;highlighter-rouge&quot;&gt;try-catch&lt;/code&gt; mechanisms
to sections you find prone to error, typically sections doing IO with remote
systems and services. &lt;!--more--&gt; While you realize such sections when you write
them personally, this context is lost when you use libraries in an impure
language. Clojure goes a long way in providing a pure state management concept
which shields you from errors. As long as you properly &lt;em&gt;separate&lt;/em&gt; your IO
functions, there is a limited interface on which exceptions can propagate. But
is this assurance good enough? &lt;label for=&quot;Six&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Six&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;I have experienced that once your state becomes
more and more linked to external systems, code covering these systems also tends
to spread, yielding possibly distributed error states which need to be addressed
on higher levels. &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Clojure has nice concepts of how to deal with errors beyond &lt;code class=&quot;highlighter-rouge&quot;&gt;try-catch&lt;/code&gt;
mechanisms with exceptions. There
are
&lt;a href=&quot;https://github.com/scgilardi/slingshot&quot;&gt;libraries providing the Common Lisp condition system for Clojure&lt;/a&gt; and
as &lt;a href=&quot;https://www.youtube.com/watch?v=zp0OEDcAro0&quot;&gt;Chris Houser has pointed out&lt;/a&gt;,
even a simple dynamic scoping will do&lt;label for=&quot;One&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;One&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;And will compose
properly. &lt;/span&gt;. This approach has many benefits, importantly it can allow
robustness (restarts), which are not possible when an exception has unwound the
stack.&lt;/p&gt;

&lt;h2 id=&quot;erlang-error-handling&quot;&gt;Erlang error handling&lt;/h2&gt;

&lt;p&gt;So does this cut it? I have faced a more profound problem with Clojure error
handling in &lt;a href=&quot;https://github.com/clojure/core.async&quot;&gt;core.async&lt;/a&gt;. But this only
lead me to investigate the design space a bit, most prominently
the
&lt;a href=&quot;http://erlang.org/download/armstrong_thesis_2003.pdf&quot;&gt;Erlang &lt;em&gt;Let it crash&lt;/em&gt; principle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Hindenburg_burning.jpg/631px-Hindenburg_burning.jpg&quot; alt=&quot;Hindenburg crash&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So before diving into error handling with &lt;code class=&quot;highlighter-rouge&quot;&gt;core.async&lt;/code&gt;, I will briefly describe
the Erlang error handling concept. It is a succinct feature of Erlang, which
makes
it
&lt;a href=&quot;http://learnyousomeerlang.com/types-or-lack-thereof&quot;&gt;profoundly solid as a language to build error-prone distributed systems with very high reliability despite lacking a type system&lt;/a&gt;.
Clojure with CSP &lt;code class=&quot;highlighter-rouge&quot;&gt;core.async&lt;/code&gt; is very similar in this regard, but by default it
lacks the same quality error handling.&lt;/p&gt;

&lt;p&gt;Erlang
uses &lt;a href=&quot;http://learnyousomeerlang.com/errors-and-processes&quot;&gt;links and monitors&lt;/a&gt; to
track different processes (actors) automatically and using these mechanisms
preemptively terminates processes linking to a dying process. This importantly
allows to easily restart whole subsystems if something goes wrong. You do not
handle the error locally if you are not sure what to do about it, but let your
process crash, knowing that somebody might be able to catch the error on their
monitor and deal with appropriately. Error handling is done in general at higher
levels and incrementally added when the programmer experiences errors. But
despite this lazy approach, the restarting concept allows to keep the system
available as long as some higher system entity can properly restart. Technically
there are many Erlang specific concepts like the linking of processes at runtime
by refering to their name. But this is not essential for the concept, it only
allows easier mutable adaptation of a running system and fits Erlang’s CSP
design.&lt;/p&gt;

&lt;p&gt;We can hence summarize the requirements for robust error handling by two
qualities:&lt;label for=&quot;Two&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Two&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;These are only the core requirements to recover
robustness. &lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;All&lt;/em&gt; errors must be catched and dealt with somewhere&lt;/li&gt;
  &lt;li&gt;Resources must be &lt;em&gt;properly freed&lt;/em&gt; to allow restarts&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So how does this relate to Clojure? core.async uses the concept of go-routines,
which are not the same as Erlang processes as they lack the addressing by names
(like PIDs). Instead they are passed around as values, expanding a call tree at
construction. They can be bound to vars or managed in STM primitives, but
typically are rather used as in go-lang as dedicated routines which are called.
core.async hence also does not have the send/receive mechanism of Erlang. This
is not critical though, as we can recover the error handling requirements above
without them.&lt;/p&gt;

&lt;h2 id=&quot;erlang-inspired-error-handling-in-coreasync&quot;&gt;Erlang inspired error handling in &lt;code class=&quot;highlighter-rouge&quot;&gt;core.async&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Coming back to error handling in core.async, it does not provide any error
handling by default and throwing
exceptions
&lt;a href=&quot;https://wyegelwel.github.io/Error-Handling-with-Clojure-Async/&quot;&gt;is broken&lt;/a&gt;.
While it is easy to fix it by installing a default handler for all errors
somewhere, it does not recover the Erlang qualities, but only installs one
global handler. One might wonder whether &lt;code class=&quot;highlighter-rouge&quot;&gt;go-lang&lt;/code&gt; itself has a good error
handling, but I have found out that it has no comparable concepts&lt;label for=&quot;Four&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Four&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;It is not seen as a problem really.  &lt;/span&gt; and advertises to deal with
errors locally when possible. This does not recover the robustness requirements
mentioned above and can leave subsystems in a broken state by wrongly handling
errors in a &lt;em&gt;too local&lt;/em&gt; scope. So what we need to do is ensure that we catch all
exceptions and propagate them and also that once we decide to deal with an
exception, we are able to restart the subsystem affected by it. This requires
&lt;em&gt;bidirectional&lt;/em&gt; communication, as we need to signal our restart intent.
Importantly it is hence not enough to put exceptions on an error channel with a
go-try macro construct.&lt;/p&gt;

&lt;p&gt;To recover Erlang-&lt;em&gt;like&lt;/em&gt; subsystem modelling of errors, we need to assume to
have been passed an entity into our scope which tracks and gets all the errors.
We will call this entity our supervisor in similar terminology to Erlang. This
entity needs to track all errors (1.) and all go-routines (2.). The latter is
necessary so it can wait for their termination, if it decides to restart the
subsystem. There is only one problem left here, which is nicely solved in Erlang
by its &lt;em&gt;preemptive scheduling&lt;/em&gt; and error-handling support in the runtime. How to
terminate the go-routines to &lt;em&gt;enforce&lt;/em&gt; a restart? The supervisor could easily wait
for a go-routine&lt;label for=&quot;Three&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Three&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;e.g. a &lt;code class=&quot;highlighter-rouge&quot;&gt;go-loop&lt;/code&gt; &lt;/span&gt; forever, effectively
defeating the whole purpose of robustness and availability. Since Clojure cannot
preemptively reschedule code in go-routines, we have to interrupt them
differently.&lt;/p&gt;

&lt;p&gt;We can exploit a simple observation here, almost all go-routines are written to
allow asynchronous operations on channels which typically cover most of their
wallclock time. We can control these blocking operations, since we already
intercept them with our error-handling mechanism, unblocking them by throwing an
abortion in the context, recursively unwinding all parallel go-routines. While
this behaviour goes a long way, the programmer needs to be aware that
go-routines with code that can take a long time without asynchronous operations
(e.g. with blocking IO, long computations etc.) is problematic. It is
cooperative concurrency after all.&lt;/p&gt;

&lt;p&gt;I haven’t found this to be a problem yet, but there is little we can do here,
except of doing some deep code transformation with autoinjection of code in the
go-macro, which still would not help with outside JVM
code. &lt;a href=&quot;http://docs.paralleluniverse.co/pulsar/&quot;&gt;Pulsar&lt;/a&gt; uses bytecode
instrumentation on the JVM to achieve something similar, but they have also
found that preemption is not too important in practice. We cannot use this
low-level approach with &lt;code class=&quot;highlighter-rouge&quot;&gt;core.async&lt;/code&gt;, as we also need to target JavaScript. (One
could do differnt things on the two hosts though.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fullcontact/full.async/pull/2#event-633151893&quot;&gt;So my first attempt&lt;/a&gt; at
robust error handling was to
adapt &lt;a href=&quot;https://github.com/fullcontact/full.async&quot;&gt;full.async&lt;/a&gt;. It would have
been desirable to use dynamic binding for the supervisor as it is a typical
example for a good dynamic binding and the already available &lt;code class=&quot;highlighter-rouge&quot;&gt;go-try&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;?&lt;/code&gt;
constructs keep working transparently. While this dynamic binding approach
worked well for the JVM, it
proved
&lt;a href=&quot;http://dev.clojure.org/jira/browse/CLJS-1634&quot;&gt;incompatible with ClojureScripts dynamical binding&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Somewhat reluctantly I decided
to &lt;a href=&quot;https://github.com/replikativ/superv.async&quot;&gt;fork full.async as superv.async&lt;/a&gt;
then and add a lexical argument for the supervisor to all corresponding
full.async operations. While this adds some inconvenience, the benefits outweigh
the costs for me. Not only am I now able to track all exceptions in parallel
go-routines appropriately, I can also do things
like
&lt;a href=&quot;https://github.com/replikativ/replikativ/blob/master/src/replikativ/connect.cljc#L32&quot;&gt;robust connection handling&lt;/a&gt; and
provide error handling by functional composition to the whole replication
system.&lt;/p&gt;

&lt;p&gt;&lt;label for=&quot;Seven&quot; class=&quot;margin-toggle&quot;&gt; ⊕&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;Seven&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;marginnote&quot;&gt;An example invocation of a supervisor with the corresponding async primitives and operations. &lt;/span&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;try-fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;go-try&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ex-info&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stale&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}))))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start-fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;; will be called again on retries
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;go-try&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                   &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;; you must ensure the freeing of resources:
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;on-abort&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
                     &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;do cleanup here&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;try-fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;; triggers restart after stale-timeout
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                   &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;restarting-supervisor&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start-fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;:retries&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;:stale-timeout&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While the implementation definitely needs more testing to be really fleshed out,
I am comfortable to say that it considerably improves on error-handling in
core.async today. It also communicates the normal exceptions to an embedding
environment, the supervisor just returns it in case it cannot deal with it. I
hope you find it useful and report back in
the
&lt;a href=&quot;https://gitter.im/replikativ/replikativ?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&quot;&gt;gitter chat&lt;/a&gt; or
on the Clojure mailing list :).&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Mar 2016 23:01:19 +0100</pubDate>
        <link>https://whilo.github.io/articles/16/error-handling1</link>
        <guid isPermaLink="true">https://whilo.github.io/articles/16/error-handling1</guid>
        
        
        <category>erlang</category>
        
        <category>core.async</category>
        
        <category>replikativ</category>
        
      </item>
    
      <item>
        <title>Welcome to my blog.</title>
        <description>&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;On this blog I will track different issues I am facing in the pursuit of distributed systems, including direct implementation aspects and issues with &lt;a href=&quot;http://github.com/replikativ/replikativ&quot;&gt;replikativ&lt;/a&gt;. Additionally I will write about different machine learning topics I am involved in. I hope you find it useful, feedback is appreciated!&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Mar 2016 23:01:19 +0100</pubDate>
        <link>https://whilo.github.io/articles/16/introduction</link>
        <guid isPermaLink="true">https://whilo.github.io/articles/16/introduction</guid>
        
        
        <category>org</category>
        
      </item>
    
  </channel>
</rss>
